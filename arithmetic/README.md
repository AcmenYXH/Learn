Java中实现的十大排序算法包括：

1. **冒泡排序（Bubble Sort）**
    - 原理：通过重复遍历待排序序列，比较每对相邻元素并交换顺序（如果必要），直到整个序列按升序或降序排列。
    - 时间复杂度：最好情况下为O(n)，最坏情况下和平均情况下为O(n²)。

2. **快速排序（Quick Sort）**
    - 原理：采用分治策略，选择一个“基准”元素，将数组分为两部分，一部分的所有元素都比基准小，另一部分的所有元素都比基准大，然后递归地对这两部分进行快速排序。
    - 时间复杂度：平均情况下为O(n log n)，最坏情况下为O(n²)，但通过合理选择基准可以减少这种可能性。

3. **插入排序（Insertion Sort）**
    - 原理：将每个元素按照其正确位置插入到已经排序好的子序列中，对于未排序数据，在已排序序列中从后向前扫描找到合适的位置并插入。
    - 时间复杂度：最好情况下为O(n)，当数组近乎有序时效率最高；最坏和平均情况下为O(n²)。

4. **希尔排序（Shell Sort）**
    - 原理：改进版的插入排序，通过定义不同的增量序列来分组元素，先对各组进行插入排序，随着增量逐渐减小，最后变为1时相当于普通的插入排序，使得整体序列趋于有序。
    - 时间复杂度：希尔排序不保证有固定的性能界限，但它通常在实际应用中表现得优于O(n²)。

5. **选择排序（Selection Sort）**
    - 原理：每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。
    - 时间复杂度：无论最好、最坏还是平均情况，都是O(n²)。

6. **堆排序（Heap Sort）**
    - 原理：利用完全二叉树的性质构建最大堆（或最小堆），然后将堆顶元素与末尾元素交换，并调整剩余元素重新形成堆，重复此过程直至排序完成。
    - 时间复杂度：在所有情况下均是O(n log n)。

7. **归并排序（Merge Sort）**
    - 原理：也采用分治策略，将原始序列一分为二，分别对两个子序列进行排序，然后再合并这两个已排序的子序列以得到最终排序结果。
    - 时间复杂度：无论输入序列如何，时间复杂度均为O(n log n)。

8. **桶排序（Bucket Sort）**
    - 原理：假设输入是由独立均匀分布的随机变量构成，将要排序的数据分到有限数量的桶里，对每个桶再单独排序（通常使用其他排序算法或因为数据范围较小而直接排序），最后把各个桶中的数据按照顺序依次取出即可。
    - 时间复杂度：最好情况下，当输入是均匀分布且桶足够多时，可以达到线性时间O(n)；最坏情况下则取决于具体的分配策略和所使用的内部排序算法。

9. **计数排序（Counting Sort）**
    - 原理：适用于非负整数并且数值范围不是特别大的数组，通过统计每个数出现的次数，然后根据统计的结果直接输出排序后的序列。
    - 时间复杂度：在适用场景下，计数排序的时间复杂度是O(n+k)，其中n是待排序数组的长度，k是数组中的最大值与最小值之差加上1。

10. **基数排序（Radix Sort）**
    - 原理：是一种非比较型整数排序算法，通过按照数字的每一位进行排序，从低位到高位不断进行迭代，每次迭代都会根据当前位上的数字进行一次某种排序（如计数排序）。
    - 时间复杂度：在最优情况下，即所有数字都有相同的位数时，时间复杂度为O(nk)，其中n是待排序数组的长度，k是最大数的位数。

这些排序算法各有优劣，适用于不同场景和数据特性。